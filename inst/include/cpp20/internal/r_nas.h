#ifndef CPP20_R_NAS_H
#define CPP20_R_NAS_H

#include <cpp20/internal/r_setup.h>
#include <cpp20/internal/r_types.h>
#include <bit>

namespace cpp20 {
    
// NAs

// Constructs R's NA_REAL: A Quiet NaN with the payload 1954 (0x7a2).
// Hex: 0x7ff00000 (Exp/Quiet) << 32 | 0x7a2 (Payload).
// Uses std::bit_cast for portable interpretation of the 64-bit pattern
// no manual endianness swapping required
consteval double make_na_real() {
  return std::bit_cast<double>(0x7ff00000000007a2ULL);
}

namespace internal {

template<typename T>
inline constexpr T na_value_impl() {
  static_assert(
    always_false<T>,
    "Unimplemented `na` specialisation"
  );
  return T{};
}

template<>
inline constexpr r_lgl na_value_impl<r_lgl>(){
  return r_na;
}

template<>
inline constexpr r_int na_value_impl<r_int>(){
  return r_int(std::numeric_limits<int>::min());
}

template<>
inline constexpr r_dbl na_value_impl<r_dbl>(){
  return r_dbl(make_na_real());
}

template<>
inline constexpr r_int64 na_value_impl<r_int64>(){
  return r_int64(std::numeric_limits<int64_t>::min());
}

template<>
inline constexpr r_cplx na_value_impl<r_cplx>(){
  return r_cplx(std::complex<double>{make_na_real(), make_na_real()});
}

template<>
inline constexpr r_raw na_value_impl<r_raw>(){
  return r_raw{0};
}

template<>
inline r_str na_value_impl<r_str>(){
  return r_str{NA_STRING};
}

template<>
inline r_sexp na_value_impl<r_sexp>(){
  return r_null;
}

}

template<typename T>
inline constexpr auto na(){
  return internal::na_value_impl<std::remove_cvref_t<T>>();
}

namespace internal {

template<typename T>
inline constexpr bool is_na_impl(T x) {
  if constexpr (RVal<T>){
      return unwrap(x) == unwrap(na<T>());
  } else if constexpr (CastableToRVal<T>){
    return is_na_impl(as_r_val(x));
  } else {
    return false;
  }
}


template<>
inline constexpr bool is_na_impl<r_dbl>(r_dbl x){
  return x.value != x.value;
}

template<>
inline constexpr bool is_na_impl<r_cplx>(r_cplx x){
  return is_na_impl<r_dbl>(x.re()) || is_na_impl<r_dbl>(x.im());
}

template<>
inline constexpr bool is_na_impl<r_raw>(r_raw x){
  return false;
}
 
// NULL is treated as NA of general R objects
template<>
inline bool is_na_impl<r_sexp>(r_sexp x){
  return unwrap(x) == unwrap(r_null);
}
template<>
inline bool is_na_impl<SEXP>(SEXP x){
  return x == unwrap(r_null);
}

}

template<typename T>
inline constexpr bool is_na(const T x) {
    return internal::is_na_impl<std::remove_cvref_t<T>>(x);
}

}

#endif
