#ifndef CPP20_R_NAS_H
#define CPP20_R_NAS_H

#include <cpp20/internal/r_setup.h>
#include <cpp20/internal/r_types.h>
#include <bit>

namespace cpp20 {
    
// NAs

namespace internal {

// Constructs R's NA_REAL: A Quiet NaN with the payload 1954 (0x7a2).
// Hex: 0x7ff00000 (Exp/Quiet) << 32 | 0x7a2 (Payload).
// Uses std::bit_cast for portable interpretation of the 64-bit pattern
// no manual endianness swapping required
inline consteval double make_na_real() {
  return std::bit_cast<double>(0x7ff00000000007a2ULL);
}

inline consteval uint64_t na_real_bits(){
  return std::bit_cast<uint64_t>(make_na_real());
}

inline constexpr bool is_na_real(double x){
  return std::bit_cast<uint64_t>(x) == na_real_bits();
}

// Different NaN have different bit representations, so use with care
inline consteval uint64_t nan_bits(){
  return std::bit_cast<uint64_t>(std::numeric_limits<double>::quiet_NaN());
}

}

namespace internal {

template<typename T>
inline constexpr T na_value_impl() {
  static_assert(
    always_false<T>,
    "Unimplemented `na` specialisation"
  );
  return T{};
}

template<>
inline constexpr r_lgl na_value_impl<r_lgl>(){
  return r_na;
}

template<>
inline constexpr r_int na_value_impl<r_int>(){
  return r_int(std::numeric_limits<int>::min());
}

template<>
inline constexpr r_dbl na_value_impl<r_dbl>(){
  return r_dbl(make_na_real());
}

template<>
inline constexpr r_int64 na_value_impl<r_int64>(){
  return r_int64(std::numeric_limits<int64_t>::min());
}

template<>
inline constexpr r_cplx na_value_impl<r_cplx>(){
  return r_cplx(std::complex<double>{make_na_real(), make_na_real()});
}

template<>
inline constexpr r_raw na_value_impl<r_raw>(){
  return r_raw{0};
}

template<>
inline r_str na_value_impl<r_str>(){
  return na_str;
}

template<>
inline r_sexp na_value_impl<r_sexp>(){
  return r_null;
}

}

template<typename T>
inline constexpr auto na(){
  return internal::na_value_impl<std::remove_cvref_t<T>>();
}

namespace internal {

template<typename T>
inline constexpr bool is_na_impl(const T& x) {
  if constexpr (RVal<T>){
    return unwrap(x) == unwrap(na<T>());
  } else if constexpr (CastableToRVal<T>){
    return is_na_impl(as_r_val(x));
  } else {
    return false;
  }
}

template<>
inline bool is_na_impl(const r_str& x) {
  return unwrap(x) == unwrap(na_str);
}

template<>
inline constexpr bool is_na_impl<r_dbl>(const r_dbl& x){
  return x.value != x.value;
}

template<>
inline constexpr bool is_na_impl<r_cplx>(const r_cplx& x){
  return is_na_impl<r_dbl>(x.re()) || is_na_impl<r_dbl>(x.im());
}

template<>
inline constexpr bool is_na_impl<r_raw>(const r_raw& x){
  return false;
}

}

template<typename T>
inline constexpr bool is_na(const T& x) {
    return internal::is_na_impl<std::remove_cvref_t<T>>(x);
}

template <typename T>
inline constexpr bool is_nan(T x){
  return false;
}
// NaN but not NA_REAL
template <>
inline constexpr bool is_nan(r_dbl x){
  return is_na(x) && !internal::is_na_real(unwrap(x));
}

// is a identical to b? returns true if both are NA
template<RVal T, RVal U>
inline bool identical(const T &a, const U &b) {
  return unwrap(a) == unwrap(b);
}
template<>
inline bool identical(const r_dbl &a, const r_dbl &b) {
  // If both (NA or NaN)
  if (is_na(a) && is_na(b)){
    return internal::is_na_real(unwrap(a)) == internal::is_na_real(unwrap(b));
} else {
    return unwrap(a) == unwrap(b);
}
}

}

#endif
