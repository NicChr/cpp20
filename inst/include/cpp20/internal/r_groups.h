#ifndef CPP20_R_GROUPS_H
#define CPP20_R_GROUPS_H

#include <cpp20/internal/r_vec.h>
#include <cpp20/internal/r_hash.h>

namespace cpp20 {

// 0-indexed group IDs: [0, n - 1]
struct groups {
  r_vec<r_int> ids; 
  int n_groups = 0;
  bool sorted = true;

  // Default constructor
  groups() = default;
  // Manual constructor
  explicit groups(r_vec<r_int> x, int ngroups, bool groups_sorted) : ids(std::move(x)), n_groups(ngroups), sorted(groups_sorted) {}
};

template <RVal T>
inline groups make_groups(const r_vec<T>& x) {
  using key_type = unwrap_t<T>;
    using key_type = unwrap_t<T>;
    r_size_t n = x.length();
    groups g;
    g.ids = r_vec<r_int>(n);
    g.n_groups = 0;
    g.sorted = true;
    
    if (n == 0) return groups();

    // Table Method (For int with small range)
    if constexpr (is<key_type, int>) {

        r_vec<T> rng = range(x, /*na_rm=*/true);
        
        int min_val = unwrap(rng.get(0));
        int max_val = unwrap(rng.get(1));
        
        // Check range results
        // If x had only NAs, result would also be c(NA, NA)
        
        bool all_nas = is_na(min_val) && is_na(max_val);
        int64_t range_span = 0;
        
        if (!all_nas) {
             range_span = static_cast<int64_t>(max_val) - static_cast<int64_t>(min_val);
        }

        // Table vs Hash Map
        // Table is faster if range is reasonably small (e.g. < 20M)
        constexpr int64_t MAX_TABLE_SIZE = 20000000; 


        if (all_nas) {
          // If all NAs, just return all zeroes
          g.ids.fill(0, n, 0);
          g.n_groups = 1;
          g.sorted = true;
          return g;
       }

        if (!all_nas && range_span < MAX_TABLE_SIZE) {
            
            // --- FAST TABLE PATH ---
            
            // Table maps (value - min_val) -> group_id
            // std::vector<int> table(range_span + 1, -1);
            r_vec<r_int> table(range_span + 1, -1);
            int na_group_id = -1; // Special slot for NA
            
            auto* RESTRICT p_x = x.data();
            auto* RESTRICT p_id = g.ids.data();
            auto* RESTRICT p_table = table.data();
            
            int next_id = 0;
            int last_id = 0;
            
            for(r_size_t i = 0; i < n; ++i) {
                int val = p_x[i];
                
                // Linear Scan Cache
                if (i > 0 && val == p_x[i-1]) {
                    p_id[i] = last_id;
                    continue;
                }

                int id;
                if (val == NA_INTEGER) {
                    if (na_group_id == -1) {
                        na_group_id = next_id++;
                    }
                    id = na_group_id;
                } else {
                    // Safe subtraction because we validated range
                    size_t idx = static_cast<size_t>((long long)val - min_val);
                  
                    id = p_table[idx];
                    if (id == -1) {
                        id = next_id++;
                        p_table[idx] = id;
                    }
                }
                
                p_id[i] = id;
                if (g.sorted && id < last_id) g.sorted = false;
                last_id = id;
            }
            g.n_groups = next_id;
            return g;
        }
      }

        ankerl::unordered_dense::map<
        key_type, 
        int, 
        internal::r_hash<T>, 
        internal::r_hash_eq<T>
      > lookup;
      lookup.reserve(n);
    
      auto* RESTRICT p_x = x.data();
      auto* RESTRICT p_id = g.ids.data();
    
      int next_id = 0;
      int last_id = 0;
      int id;
    
      for (r_size_t i = 0; i < n; ++i) {
        key_type key = p_x[i];
        auto [it, inserted] = lookup.try_emplace(key, next_id);
        if (inserted) {
          id = next_id++;
        } else {
          id = it->second;
        }
        p_id[i] = id;
    
        // check if group IDs are sorted
        // Since g.sorted was set to true by default, once it's set to false we don't need to set again
        if (g.sorted && id < last_id){
          g.sorted = false;
        }
        last_id = id;
      }
    
      g.n_groups = next_id;
      return g;
}

inline r_vec<r_int> group_starts(const groups& x){
    
    const r_vec<r_int>& group_ids = x.ids;

    int n = group_ids.length();
    int n_groups = x.n_groups;

    r_vec<r_int> out(n_groups);

    if (n_groups == 0){
        return out;
    }
    
    int curr_group;

    if (x.sorted){
        // Initialise just in-case there are groups with no group IDs (e.g. unused factor levels)
        // out.fill(0, n_groups, 0);
        const int* RESTRICT p_ids = group_ids.data();
        int* RESTRICT p_out = out.data();

        curr_group = 0;
        p_out[0] = 0;
        
        for (int i = 1; i < n; ++i){
            // New group
            if (p_ids[i] == (curr_group + 1)){
                p_out[++curr_group] = i;
            }
            //
            // if (p_ids[i] > p_ids[i - 1]){
            //     p_out[++curr_group] = i;
            // }
        }
    } else {

        // Initialise with largest int
        // so that for each group we take the min(out[i], i)
        // After passing through all data, this should reduce to the first location for each group
        out.fill(0, n_groups, r_limits<r_int>::max());
        
        const int* RESTRICT p_ids = group_ids.data();
        int* RESTRICT p_out = out.data();
        int curr_group_start;
        
        for (int i = 0; i < n; ++i){
            curr_group = p_ids[i];
            curr_group_start = p_out[curr_group];
            p_out[curr_group] = std::min(curr_group_start, i);
          }
    
        // This will set groups with no start locations to 0
        // (e.g. undropped factor levels)
        // If uncommenting the below line, make sure to remove RESTRICT keyword from pointers above
        // out.replace(0, n_groups, fill_value, 0);
    }

  return out;
}


}

#endif
